## 🔍 인덱싱(Indexing)

Continue는 \*\*태그 기반 시스템(tagging system)\*\*과 \*\*콘텐츠 주소 지정(content addressing)\*\*을 함께 사용하여, 동일한 파일을 두 번 인덱싱하지 않아도 되도록 설계되어 있습니다. 브랜치를 변경할 경우, Continue는 **새롭게 수정된 파일 중 이전에 인덱싱되지 않았던 파일만 다시 인덱싱**합니다. 이 시스템은 `CodebaseIndex` 클래스를 구현함으로써 여러 가지 "산출물(artifact)"에 대해 재사용할 수 있습니다.

---

### 용어 정리

- **artifact (산출물)**: 인덱싱을 통해 생성된 후, 이후에 사용되기 위해 저장되는 것들입니다. 예: 임베딩 데이터, 전체 텍스트 검색 인덱스, 각 파일 내 최상위 코드 스니펫의 테이블 등.
- **cacheKey**: 두 파일이 동일한지 판단하는 기준이 되는 키. 현재는 항상 **파일 내용의 해시값**입니다.
- **CodebaseIndex**: 새로운 산출물을 생성할 때 이 인덱싱 시스템을 쉽게 사용할 수 있도록 돕는 클래스입니다.

---

### 🛠️ 인덱싱 과정

1. **모든 파일의 수정된 타임스탬프 확인**
   → 이건 파일 자체를 읽는 것보다 훨씬 빠르므로 효율적입니다. Git도 동일한 방식 사용.

2. **카탈로그(=인덱싱 기록 SQLite DB)와 비교**
   → 아래 세 가지 경우로 나뉩니다:

   - 파일이 레포에는 있지만 카탈로그에는 없음 → **"추가(add)" 대상**
   - 파일이 카탈로그에는 있지만 레포에는 없음 → **"삭제(remove)" 대상**
   - 둘 다 존재하지만 타임스탬프가 최신 → **"업데이트(add)" 대상**

3. **"추가(add)" 파일 처리**

   - 동일한 `cacheKey`를 갖는 항목이 다른 브랜치에 존재하면 **"addTag"만 추가**하면 됨.
   - 그렇지 않으면 **산출물 직접 계산(compute)** 필요.

4. **"삭제(remove)" 파일 처리**

   - 동일한 `cacheKey`를 가진 항목이 단 하나뿐이면, 해당 브랜치만 사용하는 것이므로 → **"삭제(delete)"**
   - 여러 태그가 있으면 이 브랜치의 태그만 제거 → **"removeTag"**

5. **최종 단계**
   → 다음 네 가지 목록을 `CodebaseIndex`에 넘겨서 실제 인덱스를 업데이트함:

   - `compute`: 새로 산출물 생성이 필요한 파일
   - `delete`: 완전히 삭제할 파일
   - `addTag`: 다른 브랜치의 인덱스를 재사용하는 파일 (태그만 추가)
   - `removeTag`: 브랜치에서만 제거하는 파일

   → `CodebaseIndex` 클래스의 `update()` 메서드에서 위 네 목록을 받아 처리하고, 중간 진행 상태(progress)를 리턴함.
   → 이 진행 상태는 플러그인이 중간에 종료되었을 때를 대비해 인덱싱 완료 여부를 기록하는 데 사용됨.

---

## ✅ 구현된 `CodebaseIndex` 종류

`CodebaseIndexer.ts` 파일의 `getIndexesToBuild()` 함수에서 리턴되는 인덱스만 사용됩니다.

| 클래스명                      | 설명                                                                                                                                     |
| ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `CodeSnippetsCodebaseIndex`   | Tree-sitter 쿼리를 사용해 함수, 클래스 등 최상위 코드 객체 추출                                                                          |
| `FullTextSearchCodebaseIndex` | SQLite FTS5를 사용한 전체 텍스트 검색 인덱스 생성                                                                                        |
| `ChunkCodebaseIndex`          | 파일을 코드 구조에 따라 조각(chunks)으로 나누는 인덱스                                                                                   |
| `LanceDbCodebaseIndex`        | 각 조각에 대해 임베딩을 계산하고, 결과를 LanceDB 벡터 DB에 저장. SQLite에는 메타데이터 저장. 브랜치별로 LanceDB 내에 별도 테이블 생성됨. |

---

## ⚠️ 알려진 문제점

- `FullTextSearchCodebaseIndex`는 **태그(브랜치, 레포지토리) 구분을 하지 않음**
  → 결과가 의도치 않은 브랜치/레포에서 섞여 나올 수 있음
- `LanceDbCodebaseIndex`는 이를 해결하기 위해 `tableNameForTag` 함수를 통해 브랜치마다 별도 테이블 생성
- `ChunkCodebaseIndex`는 이를 위해 SQLite 내에 보조 테이블을 사용하여 태그를 구분함
